library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use IEEE.std_logic_unsigned.all;

-- Contador que avanza de 0 a 9 al ritmo del dedo en un pulsador
-- El contador avanza al soltar, no al apretar
entity sesion1_javi is
port(
clk: in std_logic;
inicio: in std_logic;
pulsador_suma: in std_logic;
pulsador_resta: in std_logic;
seven_seg: out std_logic_vector (6 downto 0);
enable_seg: out std_logic_vector (3 downto 0)
);
end sesion1_javi;

architecture Behavioral of sesion1_javi is

signal contador_unidades_seg: std_logic_vector (3 downto 0);
signal estado_suma: std_logic_vector (1 downto 0);
signal cont_filtro_suma: integer range 0 to 250000;
signal salida_suma: std_logic ;
signal estado_resta: std_logic_vector (1 downto 0);
signal salida_resta: std_logic;
signal cont_filtro_resta: integer range 0 to 250000;

begin

process(clk, inicio)
begin
if inicio='1' then	
	estado_suma<="00";
elsif rising_edge(clk) then
	case estado_suma is
	when "00" => 	cont_filtro_suma<=0;
					if pulsador_suma='0' then
						estado_suma<="00";
					else
						estado_suma<="01";
					end if;
	when "01" =>	
	                if cont_filtro_suma >= 250000 and pulsador_suma = '1' then
	                   estado_suma <= "10";
	                elsif cont_filtro_suma >= 250000 and pulsador_suma = '1' then
	                   estado_suma <= "10";
	                end if;
	                cont_filtro_suma <= cont_filtro_suma + 1;
	when "10" => 
	               if pulsador_suma = '0' then
	                   estado_suma <= "11";
	               end if;
	when others => 	cont_filtro_suma<=0;
					estado_suma<="00";
	end case;
end if;
end process;

process(clk, inicio)
begin
if inicio='1' then	
	estado_resta<="00";
elsif rising_edge(clk) then
	case estado_resta is
	when "00" => 	cont_filtro_resta<=0;
					if pulsador_resta='0' then
						estado_resta<="00";
					else
						estado_resta<="01";
					end if;
	when "01" =>	
	                if cont_filtro_resta >= 250000 and pulsador_resta = '1' then
	                   estado_resta <= "10";
	                elsif cont_filtro_resta >= 250000 and pulsador_resta = '1' then
	                   estado_resta <= "10";
	                end if;
	                cont_filtro_resta <= cont_filtro_resta + 1;
	when "10" => 
	               if pulsador_resta = '0' then
	                   estado_resta <= "11";
	               end if;
	       
	when others => 	cont_filtro_resta<=0;
					estado_resta<="00";
	end case;
end if;
end process;


process(estado_suma)
begin
case estado_suma is
	when "00" => salida_suma<='0';
	when "01" => salida_suma<='0';
	when "10" => salida_suma<='0';
	when "11" => salida_suma<='1';
	when others => salida_suma<='0';
end case;
end process;

process(estado_resta)
begin
case estado_resta is
	when "00" => salida_resta<='0';
	when "01" => salida_resta<='0';
	when "10" => salida_resta<='0';
	when "11" => salida_resta<='1';
	when others => salida_resta<='0';
end case;
end process;


process(inicio, clk)
begin
if inicio='1' then
	contador_unidades_seg<="0000";
elsif rising_edge(clk) then
	if salida_suma='1' then
		if contador_unidades_seg=9 then
			contador_unidades_seg<="0000";
		else
			contador_unidades_seg<=contador_unidades_seg+1;
		end if;
	elsif salida_resta='1' then
        if contador_unidades_seg=0 then
                contador_unidades_seg<="1001";
            else
                contador_unidades_seg<=contador_unidades_seg-1;
            end if;
	end if;
end if;
end process;


process(contador_unidades_seg)
begin
case contador_unidades_seg is
when "0000" => seven_seg<="0000001";
when "0001" => seven_seg<="1001111";
when "0010" => seven_seg<="0010010";
when "0011" => seven_seg<="0000110";
when "0100" => seven_seg<="1001100";
when "0101" => seven_seg<="0100100";
when "0110" => seven_seg<="1100000";
when "0111" => seven_seg<="0001111";
when "1000" => seven_seg<="0000000";
when "1001" => seven_seg<="0001100";
when others => seven_seg<="1111111";
end case;
end process;

enable_seg<="0111";

end Behavioral;
