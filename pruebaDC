library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.NUMERIC_STD.ALL;
use IEEE.std_logic_unsigned.ALL;

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

entity main is
port(
signal reset: in std_logic; -- button es el reset activo por nivel alto
signal clk: in std_logic; -- clk es el reloj de 125 MHz que da el propio Zynq/Zybo
signal enable: in std_logic; -- para habilitar el motor
signal inicio: in std_logic;
signal speed: in std_logic_vector (1 downto 0);
signal pwm_motor_DC: out std_logic_vector (1 downto 0)
);
end main;

architecture Behavioral of main is

signal cont_pwm: integer range 0 to 500001;
signal estado: std_logic_vector (1 downto 0);
signal tope_a_uno: integer range 0 to 500000;

begin

process (speed)
begin
case speed is
when "00" => tope_a_uno <= 50000;
when "01" => tope_a_uno <= 125000;
when "10" => tope_a_uno <= 250000;
when "11" => tope_a_uno <= 500000;
when others => tope_a_uno <= 0;
end case;
end process;

process(clk, inicio)
begin
if inicio = '1' then
    cont_pwm <= 0;
    estado <= "00";
elsif rising_edge(clk) then
    case estado is
        when "00" =>    cont_pwm <= 0;
                        estado <= "01";
                        
        when "01" =>    cont_pwm <= cont_pwm+1;
                        if cont_pwm = tope_a_uno then
                            estado <= "10";
                        else
                            estado <= "01";
                        end if;
                        
        when "10" =>    cont_pwm <= cont_pwm+1;
                        if cont_pwm = 500000 then
                            estado <= "00";
                        end if;
        when others =>  cont_pwm <= 0;
                        estado <= "00";
    end case;
end if;
end process;


pwm_motor_DC(1) <= '0';

process(estado)
begin
    case estado is
        when "00" =>    pwm_motor_DC(0) <= '0';
        when "01" =>    pwm_motor_DC(0) <= '1';
        when "10" =>    pwm_motor_DC(0) <= '0';
        when others =>  pwm_motor_DC(0) <= '0';
    end case;
end process;


end Behavioral;
